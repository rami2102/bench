#!/usr/bin/env bash
# Generate round-robin and per-language test list files from the multi-swe-bench-mini dataset.
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BENCH_DIR="$(cd "$SCRIPT_DIR/../.." && pwd)"

DATASET="$BENCH_DIR/cache/multilang/multi-swe-bench-mini.jsonl"
OUT_DIR="$BENCH_DIR/tests/multilang"

usage() {
    echo "Usage: $(basename "$0") [--help]"
    echo ""
    echo "Generate round-robin and per-language test list files"
    echo "from the multi-swe-bench-mini dataset."
}

ensure_output_dir() {
    mkdir -p "$OUT_DIR"
}

generate_test_lists() {
    ensure_output_dir; python3 - "$DATASET" "$OUT_DIR" <<'PYEOF'
import json, sys
from collections import defaultdict
from itertools import cycle

dataset_path = sys.argv[1]
out_dir = sys.argv[2]

DIFFICULTY_ORDER = {"easy": 0, "medium": 1, "hard": 2}
LANG_ORDER = ["python", "js", "ts", "java", "c++", "go", "rust", "c"]
LANG_FILE_NAMES = {
    "python": "by-language-python.md",
    "js": "by-language-javascript.md",
    "ts": "by-language-typescript.md",
    "java": "by-language-java.md",
    "c++": "by-language-cpp.md",
    "go": "by-language-go.md",
    "rust": "by-language-rust.md",
    "c": "by-language-c.md",
}
LANG_DISPLAY = {
    "python": "Python",
    "js": "JavaScript",
    "ts": "TypeScript",
    "java": "Java",
    "c++": "C++",
    "go": "Go",
    "rust": "Rust",
    "c": "C",
}

# Read and group by language
by_lang = defaultdict(list)
with open(dataset_path) as f:
    for line in f:
        d = json.loads(line)
        by_lang[d["language"]].append(d)

# Sort each language group by difficulty (easy, medium, hard)
for lang in by_lang:
    by_lang[lang].sort(key=lambda d: (DIFFICULTY_ORDER.get(d["difficulty"], 99), d["instance_id"]))

# --- Per-language files ---
for lang in LANG_ORDER:
    if lang not in by_lang:
        continue
    fname = f"{out_dir}/{LANG_FILE_NAMES[lang]}"
    with open(fname, "w") as f:
        f.write(f"# {LANG_DISPLAY[lang]} instances from multi-swe-bench-mini\n")
        f.write(f"# Sorted by difficulty: easy, medium, hard\n\n")
        for d in by_lang[lang]:
            f.write(d["instance_id"] + "\n")

# --- Round-robin file ---
# Build per-language queues (already sorted by difficulty)
queues = {lang: list(by_lang[lang]) for lang in LANG_ORDER if lang in by_lang}
active_langs = [lang for lang in LANG_ORDER if lang in queues]

rr_path = f"{out_dir}/round-robin-by-language.md"
with open(rr_path, "w") as f:
    f.write("# Round-robin test list â€“ multi-swe-bench-mini\n")
    f.write("# Interleaved across languages: " + ", ".join(LANG_DISPLAY[l] for l in active_langs) + "\n")
    f.write("# Within each language sorted by difficulty: easy, medium, hard\n")
    f.write("# Generated by scripts/languages/multilang-build-test-lists.sh\n\n")

    line_num = 0
    while active_langs:
        next_active = []
        for lang in active_langs:
            if not queues[lang]:
                continue
            # Annotate every 8 lines
            if line_num % 8 == 0:
                f.write(f"# --- {LANG_DISPLAY[lang]} ---\n")
            item = queues[lang].pop(0)
            f.write(item["instance_id"] + "\n")
            line_num += 1
            if queues[lang]:
                next_active.append(lang)
        active_langs = next_active

print(f"Generated {rr_path}")
for lang in LANG_ORDER:
    if lang in LANG_FILE_NAMES and lang in by_lang:
        print(f"Generated {out_dir}/{LANG_FILE_NAMES[lang]}")
PYEOF
}

parse_args() {
    for arg in "$@"; do
        case "$arg" in
            --help|-h)
                usage
                exit 0
                ;;
        esac
    done
}

main() {
    parse_args "$@"
    generate_test_lists
}

main "$@"
